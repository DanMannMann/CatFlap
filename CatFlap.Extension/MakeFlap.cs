//------------------------------------------------------------------------------
// <copyright file="MakeFlap.cs" company="Company">
//     Copyright (c) Company.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

using System;
using System.ComponentModel.Design;
using System.Globalization;
using Microsoft.VisualStudio.Shell;
using Microsoft.VisualStudio.Shell.Interop;
using EnvDTE;
using EnvDTE80;
using System.IO;
using System.Windows.Forms;
using System.Collections.Generic;
using System.Text;
using System.Linq;

namespace VSIXProject1
{
	/// <summary>
	/// Command handler
	/// </summary>
	internal sealed class MakeFlap
	{
		private static string template = @"//
//  This file was generated by the CatFlap extension
//

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using FelineSoft.CatFlap;

namespace $rootnamespace$
{
    public class $safeitemname$ : CatFlap<$contexttype$>
    {
        public $safeitemname$()
            : base(() => new $contexttype$())
        {
            $accessorinstantiation$        }

        $accessordefinition$
    }
}";

		/// <summary>
		/// Command ID.
		/// </summary>
		public const int CommandId = 0x0100;

		/// <summary>
		/// Command menu group (command set GUID).
		/// </summary>
		public static readonly Guid CommandSet = new Guid("5f607c16-f4c3-4ce5-b22a-37df9156e9d7");

		public static readonly Guid SlnCommandSet = new Guid("5f607c16-f4c3-4ce5-b22a-37df9156e9d8");

		/// <summary>
		/// VS Package that provides this command, not null.
		/// </summary>
		private readonly Package package;
		private DTE2 dte;

		/// <summary>
		/// Initializes a new instance of the <see cref="MakeFlap"/> class.
		/// Adds our command handlers for menu (commands must exist in the command table file)
		/// </summary>
		/// <param name="package">Owner package, not null.</param>
		private MakeFlap(Package package, DTE2 dte)
		{
			if (package == null)
			{
				throw new ArgumentNullException("package");
			}

			this.package = package;
			this.dte = dte;

			OleMenuCommandService commandService = this.ServiceProvider.GetService(typeof(IMenuCommandService)) as OleMenuCommandService;
			if (commandService != null)
			{
				var menuCommandID = new CommandID(CommandSet, CommandId);
				var menuItem = new MenuCommand(this.MenuItemCallback, menuCommandID);
				commandService.AddCommand(menuItem);

				menuCommandID = new CommandID(SlnCommandSet, CommandId);
				menuItem = new MenuCommand(this.SlnMenuItemCallback, menuCommandID);
				commandService.AddCommand(menuItem);
			}
		}

		/// <summary>
		/// Gets the instance of the command.
		/// </summary>
		public static MakeFlap Instance
		{
			get;
			private set;
		}

		/// <summary>
		/// Gets the service provider from the owner package.
		/// </summary>
		private IServiceProvider ServiceProvider
		{
			get
			{
				return this.package;
			}
		}

		/// <summary>
		/// This function is the callback used to execute the command when the menu item is clicked.
		/// See the constructor to see how the menu item is associated with this function using
		/// OleMenuCommandService service and MenuCommand class.
		/// </summary>
		/// <param name="sender">Event sender.</param>
		/// <param name="e">Event args.</param>
		private void MenuItemCallback(object sender, EventArgs e)
		{
			CodeElement codeElement = GetClassElement();
			if (codeElement == null)
			{
				ShowMessage("No class found at the current cursor position");
				return;
			}

			CodeClass codeClass = CodeElementToDbContextCodeClass(codeElement);
			if (codeClass == null)
			{
				ShowMessage("The class " + codeElement.FullName + " at the current cursor position does not inherit System.Data.Entity.DbContext");
				return;
			}

			CreateFlap(codeClass);
		}

		private void CreateFlap(CodeClass codeClass)
		{
			var fileName = EnsureUniqueFileName(codeClass);
			if (fileName == null)
			{
				//User has cancelled when asked to choose a file to write to
				return;
			}

			string result = GetFileContent(codeClass);
			File.WriteAllText(fileName, result);
			((codeClass.ProjectItem.Collection.Parent as ProjectItem).Collection.Parent as ProjectItem).ProjectItems.AddFromFile(fileName);
			dte.ItemOperations.OpenFile(fileName);
		}

		private void SlnMenuItemCallback(object sender, EventArgs e)
		{
			bool done = false;
			var items = new List<SelectedItem>(dte.SelectedItems.Cast<SelectedItem>());
			foreach (SelectedItem item in items)
			{
				if (item.ProjectItem != null)
				{
					var projItem = item.ProjectItem;
					if (projItem.FileCodeModel != null)
					{
						done = CreateFlapsIfNeeded(projItem.FileCodeModel.CodeElements) || done;
					}
					if (item.ProjectItem.ProjectItems != null)
					{
						done = FindFlaps(projItem.ProjectItems) || done;
					}
				}
			}

			if (!done)
			{
				ShowMessage("No entity framework definitions selected");
			}
		}

		private bool FindFlaps(ProjectItems items)
		{
			bool done = false;

			foreach (ProjectItem i in items)
			{
				if (i.FileCodeModel != null)
				{
					done = CreateFlapsIfNeeded(i.FileCodeModel.CodeElements) || done;
				}
				if (i.ProjectItems != null)
				{
					done = FindFlaps(i.ProjectItems) || done;
				}
			}

			return done;
		}

		private bool CreateFlapsIfNeeded(CodeElements i)
		{
			bool done = false;

			foreach (CodeElement codeElement in i)
			{
				if (codeElement.Kind == vsCMElement.vsCMElementClass)
				{
					var codeClass = CodeElementToDbContextCodeClass(codeElement);
					if (codeClass != null)
					{
						CreateFlap(codeClass);
						done = true;
					}
				}
				else if (codeElement.Kind == vsCMElement.vsCMElementNamespace)
				{
					done = CreateFlapsIfNeeded(codeElement.Children) || done;
				}
			}

			return done;
		}

		private string GetFileContent(CodeClass codeClass)
		{
			var props = GetProperties(codeClass);
			var className = codeClass.Name + "CatFlap";
			string result = template;
			var replacementsDictionary = new Dictionary<string, string>();
			replacementsDictionary.Add("$safeitemname$", className);
			replacementsDictionary.Add("$contexttype$", codeClass.FullName);
			replacementsDictionary.Add("$rootnamespace$", codeClass.Namespace.FullName);
			StringBuilder accessorInsts = new StringBuilder();
			StringBuilder accessorDefs = new StringBuilder();
			StringBuilder proxyDefs = new StringBuilder();
			bool first = true;
			string propSpacer = "", setSpacer = "";

			foreach (var item in props)
			{
				if (first)
				{
					first = false;
				}
				else
				{
					propSpacer = "        ";
					setSpacer = "            ";
				}

				accessorInsts.AppendLine(setSpacer + item.Value + " = CreateAccessor<global::" + item.Key + ">();");
				accessorDefs.AppendLine(propSpacer + "public ISetAccessor<global::" + codeClass.FullName + ", global::" + item.Key + "> " + item.Value + " { get; private set; }");
				accessorDefs.AppendLine();
			}
			replacementsDictionary.Add("$accessorinstantiation$", accessorInsts.ToString());
			replacementsDictionary.Add("$accessordefinition$", accessorDefs.ToString());
			foreach (var key in replacementsDictionary.Keys)
			{
				result = result.Replace(key, replacementsDictionary[key]);
			}

			return result;
		}

		private string EnsureUniqueFileName(CodeClass codeClass)
		{
			string dir = Path.GetDirectoryName(codeClass.ProjectItem.FileNames[1]);
			string fileName = codeClass.Name + ".catflap.cs";
			fileName = Path.Combine(dir, fileName);
			fileName = fileName.Replace("<", "")
							   .Replace(">", "");

			if (File.Exists(fileName))
			{
				string newFileName = fileName;
				for (int i = 2; i <= 10; i++)
				{
					newFileName = Path.Combine(dir, Path.GetFileNameWithoutExtension(fileName) + "_" + i + ".catflap.cs");
					if (!File.Exists(newFileName))
						break;
				}

				if (File.Exists(newFileName))
				{
					using (var dialog = new SaveFileDialog())
					{
						dialog.InitialDirectory = dir;
						dialog.FileName = fileName;
						if (dialog.ShowDialog() == DialogResult.OK)
							newFileName = dialog.FileName;
						else
							return null; //user canceled everything

					}
				}
				fileName = newFileName;
			}

			return fileName;
		}

		private Dictionary<string,string> GetProperties(CodeClass codeClass)
		{
			var props = new Dictionary<string, string>();
			foreach (CodeElement item in codeClass.Members)
			{
				if (item.Kind == vsCMElement.vsCMElementProperty)
				{
					var codeProperty = (CodeProperty)item;
					try
					{
						if (!codeProperty.Type.AsFullName.StartsWith("System.Data.Entity.DbSet<") && !codeProperty.Type.AsFullName.StartsWith("System.Data.Entity.IDbSet<"))
						{
							continue;
						}
						var start = codeProperty.Type.AsFullName.IndexOf("<");
						var end = codeProperty.Type.AsFullName.LastIndexOf(">");
						var genericParameter = codeProperty.Type.AsFullName.Substring(start + 1, end - start - 1);
						props.Add(genericParameter, codeProperty.Name);
					}
					catch
					{

					}
				}
			}
			return props;
		}

		private CodeClass CodeElementToDbContextCodeClass(CodeElement elem)
		{
			var codeClass = (CodeClass)elem;
			foreach (CodeElement b in codeClass.Bases)
			{
				if (b.FullName.Contains("System.Data.Entity.DbContext"))
				{
					return codeClass;
				}
			}
			return null;
		}

		private void ShowMessage(string msg)
		{
			VsShellUtilities.ShowMessageBox(
				this.ServiceProvider, 
				msg, 
				"CatFlap", OLEMSGICON.OLEMSGICON_INFO, 
				OLEMSGBUTTON.OLEMSGBUTTON_OK, 
				OLEMSGDEFBUTTON.OLEMSGDEFBUTTON_FIRST);
		}

		private CodeElement GetClassElement()
		{
			TextSelection sel =
						(TextSelection)dte.ActiveDocument.Selection;
			TextPoint pnt = (TextPoint)sel.ActivePoint;

			// Discover every code element containing the insertion point.
			FileCodeModel fcm =
				dte.ActiveDocument.ProjectItem.FileCodeModel;
			CodeElement elem;
			try
			{
				elem = fcm.CodeElementFromPoint(pnt, vsCMElement.vsCMElementClass);
			}
			catch
			{
				elem = null;
			}
			return elem;
		}

		internal static void Initialize(MakeFlapPackage package, DTE2 dte)
		{
			Instance = new MakeFlap(package, dte);
		}
	}
}
